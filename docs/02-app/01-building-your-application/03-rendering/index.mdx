---
title: Rendering
description: Learn the differences between Next.js rendering environments, strategies, and runtimes.
---

Rendering converts the code you write into user interfaces. This section will help you understand the differences between rendering environments, strategies, runtimes, and how Client and Server components are rendered.

## Fundamentals

To understand rendering in React and Next.js, it's helpful to be familiar with five foundational web concepts:

- The [Environments](#environemnts) your application code can be rendered in.
- The [Runtimes](#runtimes) that execute your application code.
- The [Rendering Strategies](#rendering-strategies) which determine how much code is rendered in each environment, and how much of it is cached.
- The [Request-Response Lifecycle](#request-response-lifecycle) that's initiated when a user visits or interacts with your application.
- The [Network Boundary](#network-boundary) that separates server and client code (module graphs).

### React Rendering Environments

There are two environments where web applications can be rendered: the client and the server.

<Image
  alt="Client and Server Environments"
  srcLight="/docs/light/client-and-server-environments.png"
  srcDark="/docs/dark/client-and-server-environments.png"
  width="1600"
  height="672"
/>

- The **client** refers to the browser on a user's device that sends a request to a server for your application code. It then turns the response from the server into a user-friendly interface.
- The **server** refers to the computer in a data center that stores your application code, receives requests from a client, and sends back an appropriate response.

Historically, developers had to use different languages (e.g. JavaScript, PHP) and frameworks when writing code for the server and the client. With React, developers can use the **same language** (JavaScript), and the **same framework** (e.g. Next.js or your framework of choice). This flexibility is great as it allows you to seamlessly write code for the server or the client without context switching - but this flexibility also introduces new challenges.

A major challenge is that each environment has its own set of roles, capabilities, and constraints. Therefore, the code you write for the server and the client cannot be the same, and there are certain operations (e.g. fetching data) that are better suited for one environment over the other.

Understanding the differences between environments is key to effectively using Server and Client Components. We'll cover the differences and use cases in more detail on the [Server and Client Components](/docs/app/building-your-application/rendering/01-server-and-client-components) page, for now, let's continue building on our foundation.

### Next.js Runtimes

In the context of Next.js, runtime refers to the set of libraries, APIs, and general functionality available to your code during execution.

On the server, there are two runtimes where parts of your application code can be rendered:

- The **Node.js Runtime** (default) has access to all Node.js APIs and compatible packages from the ecosystem.
- The **Edge Runtime** is based on [Web APIs](/docs/app/api-reference/edge).

By default, the `app` directory uses the Node.js runtime. However, you can opt into different runtimes (e.g. Edge) on a per-route basis.

Learn more about the [Edge and Node.js Runtimes](/docs/app/building-your-application/rendering/03-edge-and-nodejs-runtimes).
