---
title: Rendering
description: Learn the differences between Next.js rendering environments, strategies, and runtimes.
---

Rendering converts the code you write into user interfaces. This section will help you understand the differences between rendering environments, strategies, runtimes, and how Client and Server components are rendered.

## Fundamentals

To understand rendering in React and Next.js, it's helpful to be familiar with five foundational web concepts:

- The [Environments](#environemnts) your application code can be rendered in.
- The [Runtimes](#runtimes) that execute your application code.
- The [Rendering Strategies](#rendering-strategies) which determine how much code is rendered in each environment, and how much of it is cached.
- The [Request-Response Lifecycle](#request-response-lifecycle) that's initiated when a user visits or interacts with your application.
- The [Network Boundary](#network-boundary) that separates server and client code (module graphs).

### React Rendering Environments

There are two environments where web applications can be rendered: the client and the server.

<Image
  alt="Client and Server Environments"
  srcLight="/docs/light/client-and-server-environments.png"
  srcDark="/docs/dark/client-and-server-environments.png"
  width="1600"
  height="672"
/>

- The **client** refers to the browser on a user's device that sends a request to a server for your application code. It then turns the response from the server into a user-friendly interface.
- The **server** refers to the computer in a data center that stores your application code, receives requests from a client, and sends back an appropriate response.

Historically, developers had to use different languages (e.g. JavaScript, PHP) and frameworks when writing code for the server and the client. With React, developers can use the **same language** (JavaScript), and the **same framework** (e.g. Next.js or your framework of choice). This flexibility is great as it allows you to seamlessly write code for the server or the client without context switching - but this flexibility also introduces new challenges.

A major challenge is that each environment has its own set of roles, capabilities, and constraints. Therefore, the code you write for the server and the client cannot be the same, and there are certain operations (e.g. fetching data) that are better suited for one environment over the other.

Understanding the differences between environments is key to effectively using Server and Client Components. We'll cover the differences and use cases in more detail on the [Server and Client Components](/docs/app/building-your-application/rendering/01-server-and-client-components) page, for now, let's continue building on our foundation.

### Next.js Runtimes

In the context of Next.js, runtime refers to the set of libraries, APIs, and general functionality available to your code during execution.

On the server, there are two runtimes where parts of your application code can be rendered:

- The **Node.js Runtime** (default) has access to all Node.js APIs and compatible packages from the ecosystem.
- The **Edge Runtime** is based on [Web APIs](/docs/app/api-reference/edge).

By default, the `app` directory uses the Node.js runtime. However, you can opt into different runtimes (e.g. Edge) on a per-route basis.

Learn more about the [Edge and Node.js Runtimes](/docs/app/building-your-application/rendering/03-edge-and-nodejs-runtimes).

### Rendering Strategies

Over the years, the web has gone through several architectural models that have shifted how much code is rendered on the server vs. the client. We call these **Rendering Strategies**, and you may have already used some of them. For example, Multi-page Applications (MPA), Single-page Applications (SPA), Server-side Rendering (SSR), Static Site Generation (SSG), Client-side Rendering (CSR), etc.

In the App Router, there are three rendering strategies:

- **Static Rendering (Default)**: At build time, components are rendered on the server, and the result of the rendering work is [cached](/docs/app/building-your-application/caching#full-route-cache) and shared across requests.
- **Dynamic Rendering**: At request time, components are rendered on the server or the client (depending on whether they are Server or Client components).
- **Streaming**: At request time, components are rendered on the server, and the result of the work is streamed to the client as it becomes ready. In React, this is called **Streaming Server-side Rendering**.

The rendering work is also split by routes, allowing you to use different rendering strategies in the same application.

> **Good to know:**
>
> - We are working on introducing Hybrid Rendering to Next.js, which will automatically determine the best rendering strategy for each route segment.

### Request-Response Lifecycle

Each rendering strategy mentioned above has its benefits and drawbacks, but, broadly speaking, all rendering strategies follow the same **Request-Response Lifecycle**:

<Image
  alt="Request-Response Lifecycle"
  srcLight="/docs/light/request-response-lifecycle.png"
  srcDark="/docs/dark/request-response-lifecycle.png"
  width=""
  height=""
/>

1. **User Action:** The user interacts with a web application, which could be clicking a link, submitting a form, or typing a URL directly into the browser's address bar.
2. **HTTP Request:** The client sends a [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP) request to the server. This request contains necessary information about what resource is being requested, what method should be used (e.g. `GET`, `POST`), and additional data if necessary, like form data or tokens.
3. **Server Processing:** The server processes the request and responds with the appropriate resources. This may involve several steps like routing, querying a database, performing some logic, rendering the HTML of a page, etc.
4. **HTTP Response:** After processing the request, the server sends a HTTP response back to the client. This response contains a status code (which tells the client whether the request was successful or not) and the requested resources. These resources can be a HTML document, static assets like images, JSON files, or some other type of resource. In the case of React, the server also responds with the [RSC Payload](/docs/app/building-your-application/rendering/server-and-client-components#rsc-payload).
5. **Client Processing:** The client receives the response from the server, and parses the HTML, CSS, and JavaScript to render the user interface. If there are additional resources to be loaded, like images, the browser will send additional requests for these resources, each of which goes through the same lifecycle. In the case of React, React consolidates the Server and Client modules graphs into a single Component tree, and updates the DOM.
6. **User Interaction:** Once the user interface is rendered, the user can interact with the user interface, and the whole process starts again.

Understanding the lifecycle is important because it helps us [understand the flow of code](#unidirectional-flow) and where Server and Client Components fit in. In the next section, we'll cover the **Network Boundary** and how it relates to components.

> - If you're interested in learning more about previous rendering strategies (SSG, SSR, and CSR), see the [Pages Router documentation](https://nextjs.org/docs/pages/building-your-application/rendering).
