---
title: Going to Production
description: Before taking your Next.js application to production, here are some recommendations to ensure the best user experience.
---

Before taking your Next.js application to production, here are some recommendations to ensure the best user experience.

## Overview

- Use [caching](/docs/app/building-your-application/caching) wherever possible.
- Ensure your database and backend are deployed in the same region.
- Aim to reduce client-side JavaScript bundle sizes by [moving the "use client" boundaries down the React component tree](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns#moving-client-components-down-the-tree). 
- Prevent sensitive data from being exposed to the client with [tainting](/docs/app/building-your-application/data-fetching/patterns#preventing-sensitive-data-from-being-exposed-to-the-client)
- Ensure errors in nested route segments are handled gracefully with the [error.js file](https://nextjs.org/docs/app/building-your-application/routing/error-handling)
- Customize your 404 (Not Found) responses using the [`notfound()`](/docs/app/api-reference/functions/not-found) function and [`not-found.js` file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)
- Ensure you are [measuring performance](/docs/app/building-your-application/optimizing/analytics).
- Run [Lighthouse](https://developers.google.com/web/tools/lighthouse) to check for performance, best practices, accessibility, and SEO. For best results, use a production build of Next.js and use incognito in your browser so results aren't affected by extensions.
- Review [Supported Browsers and Features](/docs/architecture/supported-browsers).
- Optimize the user experience with built-in components: 
  - [Images](/docs/app/building-your-application/optimizing/images)
  - [Fonts](/docs/app/building-your-application/optimizing/fonts)
  - [Scripts](/docs/app/building-your-application/optimizing/scripts)
  - [Link](/docs/app/building-your-application/routing/linking-and-navigating)
- Improve [loading performance](#loading-performance)
- Consider adding a [Content Security Policy](/docs/app/building-your-application/configuring/content-security-policy)

## Caching

Caching is essential for improving response times and reducing requests to external services. The App Router in Next.js offers robust caching capabilities, catering to both static and dynamic content as well as server actions.

- **Static Asset Caching:**
  Next.js automatically adds caching headers to immutable assets in **`/public`** or other static directories. Assets like CSS, static images, and other media are ideal candidates for long-term caching as they rarely change. The default caching headers applied are:

  ```jsx
  Cache-Control: public, max-age=31536000, immutable
  ```

  This setup ensures that these assets are cached efficiently, reducing load times for returning users.

- **Data Cache for Dynamic Content:**
  Next.js's built-in Data Cache persists results of data fetches across server requests and deployments. By default, fetch requests are cached, allowing data to be reused in subsequent requests. This feature is particularly useful for dynamic content that doesn't change frequently.
- **Server-Side Caching and Revalidation:**
  Caching behavior for dynamic data fetched on the server can be controlled through various strategies. Next.js supports time-based revalidation (automatically refreshing the cache after a set period) and on-demand revalidation (refreshing the cache based on specific events). This ensures that users always receive the most up-to-date content without unnecessary delays.
- **Caching in Server Actions and Route Handlers:**
  Custom caching strategies can be implemented in Server Actions and Route Handlers. Developers can configure fetch requests to adhere to specific caching requirements, including opting for default settings like `force-cache`.
- **Opting Out of Caching:**
  There are scenarios where caching might not be desirable. Next.js allows opting out of the Data Cache for specific fetch requests. This can be achieved with settings such as `cache: 'no-store'` or `revalidate: 0`.

## Reducing JavaScript Size

Making sure your website sends less JavaScript to the browser is very important for speed. To help you understand and manage what goes into your JavaScript files, you can use these tools:

- [Import Cost](https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost) – Shows the size of each package you import right in VSCode.
- [Package Phobia](https://packagephobia.com/) – Helps you see the size impact of adding new dev dependencies to your project.
- [Bundle Phobia](https://bundlephobia.com/) - Tells you how much a new dependency could increase your JavaScript size.
- [Webpack Bundle Analyzer](https://github.com/vercel/next.js/tree/canary/packages/next-bundle-analyzer) – Creates a visual, interactive map of your webpack output files to show where space is used.
- [bundlejs](https://bundlejs.com/) - A browser tool for bundling and minifying projects, showing compressed sizes.

Additionally, make sure to implement the recommended optimization strategies.

- Optimize Server Actions - Focus on simplifying and speeding up your server actions. This can be achieved by optimizing database queries, reducing external API calls, and ensuring server-side computations are efficient. Efficient server-side processing helps reduce the time it takes for your pages to load and improves the overall performance of your website.
- Minimize Client-Side JavaScript - It's important to keep JavaScript on the client-side as small as possible for quicker website loading and a better user experience.

### Optimizing with **[`@next/bundle-analyzer`](https://www.npmjs.com/package/@next/bundle-analyzer)**

`@next/bundle-analyzer` is a plugin for Next.js that helps manage the size of your JavaScript files. It shows you how big each part of your webpack output is. This is helpful because you can find and fix parts of your code that are too large. For example, you might remove large dependencies, split your code, or only load some parts when needed.

How to use `@next/bundle-analyzer`:

1. **Install**: Run `npm install @next/bundle-analyzer webpack-bundle-analyzer`.
2. **Configure**: Add the bundle analyzer's settings to your `next.config.js`.

```js
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})
module.exports = withBundleAnalyzer({})
```

3. **Run Analysis**: Use `ANALYZE=true npm run build` to start looking at your file sizes.
4. **Review Findings**: Check the report to see where you can make improvements.

Doing this regularly while you develop and before you launch your site is important to keep your code efficient.

## Logging

Since Next.js runs on both the client and server, there are multiple forms of logging supported:

- `console.log` in the browser
- `stdout` on the server

If you want a structured logging package, we recommend [Pino](https://www.npmjs.com/package/pino). If you're using Vercel, there are [pre-built logging integrations](https://vercel.com/integrations?utm_source=next-site&utm_medium=docs&utm_campaign=next-website#logging) compatible with Next.js.

## **Error Handling**

Proper error handling is key to keeping your application stable and providing a good user experience. This is especially important with the dynamic routes and server actions in the App Router.

**Use of `error.js` for Error Handling**:

The `error.js` file convention is used for gracefully handling runtime errors in nested routes. It automatically wraps a route segment and its nested children in a React Error Boundary, allowing you to create a tailored error UI and isolate errors to specific segments while keeping the rest of the application functional.

**Handling Server Errors**:

If an error is thrown inside a Server Component, Next.js forwards an `Error` object to the nearest `error.js` file. This object includes a generic message and a digest property in production as a security measure to prevent leaking sensitive details.

## Loading Performance

To improve loading performance, you first need to determine what to measure and how to measure it. [Core Web Vitals](https://vercel.com/blog/core-web-vitals?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) is a good industry standard that is measured using your own web browser. If you are not familiar with the metrics of Core Web Vitals, review this [blog post](https://vercel.com/blog/core-web-vitals?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) and determine which specific metric/s will be your drivers for loading performance. Ideally, you would want to measure the loading performance in the following environments:

- In the lab, using your own computer or a simulator.
- In the field, using real-world data from actual visitors.
- Local, using a test that runs on your device.
- Remote, using a test that runs in the cloud.

Once you are able to measure the loading performance, use the following strategies to improve it iteratively. That is, if you apply one strategy, measure the new performance and continue tweaking until you do not see much improvement. Then, you can move on to the next strategy.

- **Optimize Caching**: Use caching strategies as detailed in the caching section.
- **Server Actions Efficiency**: Optimize server actions for quick data retrieval and minimal processing.
- **Reduce JavaScript Bundle Sizes**: Remove unused JavaScript, and move data fetching and logic to the server.
  - Setting up your Code Editor to view import costs and sizes
  - Finding alternative smaller packages
  - Dynamically loading components and dependencies
- **Parallel Route Rendering**: Leverage the App Router’s ability to render multiple components in parallel for enhanced performance.
