---
title: Authentication
description: Learn how to implement authentication in Next.js, covering best practices, securing routes, authorization techniques, and session management.
---

To implement authentication in Next.js, familiarize yourself with three foundational concepts:

- **[Authentication](#authentication)** verifies if the user is who they say they are. It requires the user to prove their identity with something they have, such as username and password.
- **[Session Management](#session-management)** tracks the user’s state (e.g. logged in) across multiple requests.
- **[Authorization](#authorization)** decides what parts of the application the user is allowed to access.

This page demonstrates how to use Next.js features to implement common authentication, authorization and session management patterns, so you can choose the best solutions based on your application’s needs.

## Authentication

Authentication verifies a user's identity. This happens when a user logs in, either with a username and password or through a service like Google. It's all about confirming that users are really who they claim to be, protecting both the user's personal data and the application from unauthorized access or fraudulent activities.

### Authentication Strategies

Modern web applications commonly use several authentication strategies:

1. **OAuth/OpenID Connect (OIDC)**: Enable third-party access without sharing user credentials. Ideal for social media logins and Single Sign-On (SSO) solutions. They add an identity layer with OpenID Connect.
2. **Credentials-based login (Email + Password)**: A standard choice for web applications, where users log in with an email and password. Familiar and easy to implement, it requires robust security measures against threats like phishing.
3. **Passwordless/Token-based authentication**: Use email magic links or SMS one-time codes for secure, password-free access. Popular for its convenience and enhanced security, this method helps reduce password fatigue. Its limitation is the dependency on the user's email or phone availability.
4. **Passkeys/WebAuthn**: Use cryptographic credentials unique to each site, offering high security against phishing. Secure but new, this strategy can be difficult to implement.

Selecting an authentication strategy should align with your application's specific requirements, user interface considerations, and security objectives.

### Implementing Authentication

In this section, we'll explore the process of adding basic email-password authentication to a web application. While this method provides a fundamental level of security, it's worth considering more advanced options like OAuth or passwordless logins for enhanced protection against common security threats. The authentication flow we'll discuss involves a user entering their credentials into a form, which then initiates a server action for validation. Upon successful verification, the user is redirected to a designated page. Alternatively, if authentication fails, an error message is displayed.

First, introduce a login form. This form is the entry point for users to input their credentials.

```tsx filename="/app/login/page.tsx" switcher
import { authenticate } from '@/app/lib/actions'

const LoginPage = () => {
  return (
    <form action={authenticate}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Password" required />
      <button type="submit">Login</button>
    </form>
  )
}

export default LoginPage
```

This section details the creation of two input fields for email and password. Upon form submission, a server-side action, defined in the `action` attribute, is initiated. Here, it links to the `authenticate` function, ensuring the secure handling of credentials.

Next, we define the `authenticate` function in the server-side code. Located in the `lib` directory, within the `actions.ts` file, this function is vital for verifying user credentials through an authentication provider's API. As an exported asynchronous function, its core duties include credential verification and session initiation upon successful authentication.

```ts filename="/app/lib/actions.ts" switcher
'use server'

import { signIn } from '@/auth'
import { redirect } from 'next/navigation'

export async function authenticate(formData: FormData) {
  try {
    await signIn('credentials', formData)
  } catch (error) {
    if (error instanceof AuthError) {
      switch (error.type) {
        case 'CredentialsSignin':
          return 'Invalid credentials.'
        default:
          return 'Something went wrong.'
      }
    }
    throw error
  }
  redirect('/dashboard')
}
```

In this code, the `signIn` method checks the credentials against stored user data.
After the authentication provider processes the credentials, there are two possible outcomes:

- **Successful Authentication**: The user is redirected to the dashboard where user info can be fetched, indicating a successful login.
- **Failed Authentication**: If the credentials are incorrect or an error occurs, the function returns an appropriate error message.

For a more streamlined authentication setup in Next.js projects, especially when offering multiple login methods, consider using a comprehensive [authentication solution](#authentication-solutions).

This approach ensures a secure and efficient authentication process, laying the foundation for a reliable and user-friendly web application.

## Authorization

Once a user is authenticated, you’ll need to ensure the user is allowed to visit certain routes and perform operations, such as mutating data with Server Actions, or calling Route Handlers.

### Protecting Routes with Middleware

Middleware in Next.js helps you control who can access different parts of your website. This is important for keeping areas like the user dashboard safe, while letting everyone see public pages like those for marketing. It's recommended to apply Middleware across all routes and specifying exclusions for public access.

Here's how to implement middleware for authentication in Next.js:

1. **Setting Up Middleware:**
   - Create a `middleware.ts` or `.js` file in your project's root directory.
   - Include logic to authorize user access, such as checking for authentication tokens.
2. **Defining Protected Routes:**
   - Use the `matcher` option in your middleware to identify routes that require authorization checks.
3. **Middleware Logic:**
   - Write logic to verify if a user is authenticated. Check user roles or permissions for route authorization.
4. **Handling Unauthorized Access:**
   - Redirect unauthorized users to a login or error page as appropriate.

Example middleware file:

```ts filename="middleware.ts" switcher
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const currentUser = request.cookies.get('currentUser')?.value

  if (currentUser) {
    return Response.redirect(new URL('/dashboard', request.url))
  }
  return Response.redirect(new URL('/login', request.url))
}

export const config = {
  matcher: '/dashboard',
}
```

This example uses [`Response.redirect`](https://developer.mozilla.org/en-US/docs/Web/API/Response/redirect_static) for efficient, centralized access control. It handles redirects early in the request pipeline, making it efficient and ideal for broad strategies.

For specific redirection needs, the `redirect` function can be used in Server Components, Route Handlers, and Server Actions to provide more control. This is useful for role-based navigation or context-sensitive scenarios.

```js
import { redirect } from 'next/navigation'

export default function Page() {
  // Logic to determine if a redirect is needed
  const accessDenied = true
  if (accessDenied) {
    redirect('/login')
  }

  // Define other routes and logic
}
```

This flexibility is key when handling redirections based on detailed authentication outcomes or other contextual factors. For example, `redirect('/login')` in a Server Action allows for precise redirection based on the user's role or specific conditions during the authentication process.

### Protecting Server Actions

It is important to treat [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations) with the same security considerations as public-facing API endpoints. Verifying user authorization for each action is crucial. Implement checks within Server Actions to determine user permissions, such as restricting certain actions to admin users.

In the example below, we check the user's role before allowing the action to proceed:

```ts filename="app/lib/actions.ts" switcher
'use server'

// ...

export async function serverAction(request) {
  const session = await getSession()
  const userRole = session?.user?.role

  // Check if user is authorized to perform the action
  if (userRole !== 'admin') {
    throw new Error('Unauthorized access: User does not have admin privileges.')
  }

  // Proceed with the action for authorized users
  // ... implementation of the action
}
```

### Protecting Route Handlers

Route Handlers in Next.js play a vital role in managing incoming requests. Just like server actions, they should be secured to ensure that only authorized users can access certain functionalities. This often involves verifying the user's authentication status and their permissions.

Here's an example of securing a Route Handler:

```ts filename="app/api/route.ts" switcher
export async function GET() {
  // User authentication and role verification
  const session = await getSession()

  // Check if the user is authenticated
  if (!session) {
    return new Response(null, { status: 401 }) // User is not authenticated
  }

  // Check if the user has the 'admin' role
  if (session.user.role !== 'admin') {
    return new Response(null, { status: 403 }) // User is authenticated but does not have the right permissions
  }

  // Data fetching for authorized users
  // {...}
}
```

This example demonstrates a Route Handler with a two-tier security check for authentication and authorization. It first checks for an active session, and then verifies if the logged-in user is an 'admin'. This approach ensures secure access, limited to authenticated and authorized users, maintaining robust security for request processing.

### Authorization Using Server Components

[Server components](https://nextjs.org/docs/app/building-your-application/rendering/server-components) in Next.js are designed for server-side execution and offer a secure environment for integrating complex logic like authorization. They enable direct access to back-end resources, optimizing performance for data-heavy tasks and enhancing security for sensitive operations.

**Key Advantages of Server Components:**

- Server-Side Execution: Offloads complex tasks from the client, improving performance.
- Direct Back-End Access: Simplifies interactions with server resources, reducing the need for extra API endpoints.
- Enhanced Security: Ideal for critical operations like authorization, as server-side execution minimizes exposure to vulnerabilities.

**Implementing Authorization Logic in Server Components**

Implementing authorization in server components involves verifying user roles or permissions and conditionally rendering content based on these verifications.

1. **Identify Authorization Requirements**: Determine restricted access areas in your application.
2. **Fetch User Details**: Retrieve user roles or permissions from sessions or authentication contexts.
3. **Role-Based Access Control**: Check user roles or permissions using server components.
4. **Conditional Rendering**: Render components based on user authorization.
5. **Handle Unauthorized Access**: Display messages or redirect for insufficient permissions.

**Example:**

```tsx filename="app/dashboard/page.tsx" switcher
// app/dashboard/page.ts
const Dashboard = async () => {
  const session = await getSession()
  const userRole = session?.user?.role // Assuming 'role' is part of the session object

  if (userRole === 'admin') {
    return <AdminDashboard /> // Component for admin users
  } else if (userRole === 'user') {
    return <UserDashboard /> // Component for regular users
  } else {
    return <AccessDenied /> // Component shown for unauthorized access
  }
}
```

This example uses the user's role to conditionally render different dashboard components, showing `AccessDenied` for unauthorized users. Ensure secure session management and robust error handling for a seamless and secure user experience.

### Best Practices

- **Secure Session Management**: Prioritize the security of session data to prevent unauthorized access and data breaches. Use encryption and secure storage practices.
- **Dynamic Role Management**: Use a flexible system for user roles to easily adjust to changes in permissions and roles, avoiding hardcoded roles.
- **Security-First Approach**: In all aspects of authorization logic, prioritize security to safeguard user data and maintain the integrity of your application. This includes thorough testing and considering potential security vulnerabilities.

For more advanced scenarios and detailed guidance, refer to the [Next.js Data Fetching Documentation](https://nextjs.org/docs/app/building-your-application/data-fetching).

By following these best practices and utilizing the features of server components and server actions, you can create a robust, efficient, and secure authorization system in your Next.js application.

## Session Management

Effective session management is essential for maintaining a secure and continuous user experience. It involves tracking and managing a user's interaction with the application over time, ensuring that their authenticated state is preserved across different parts of the application. This prevents the need for repeated logins, enhancing both security and user convenience. There are two primary methods used for session management: cookie-based and database sessions. Each of these methods has its distinct benefits and considerations, catering to different application needs and security requirements.

### Cookie-Based Sessions

Cookie-based sessions manage user data by storing encrypted session information directly in browser cookies. Upon user login, this encrypted data is stored in the cookie. Each subsequent server request includes this cookie, minimizing the need for repeated server queries and enhancing client-side efficiency. However, this method requires careful encryption to protect sensitive data, as cookies are susceptible to client-side security risks. Additionally, while individual cookies are limited in size (typically around 4KB), techniques like cookie-chunking can overcome this limitation by dividing large session data into multiple cookies.

Setting a cookie in a Next.js project might look something like this:

**Setting a cookie on the server:**

```jsx
import { setCookie } from 'next/cookies'

export function handleLogin(req, res, sessionData) {
  const encryptedSessionData = encrypt(sessionData) // Encrypt your session data
  setCookie({ res }, 'session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // One week
    path: '/',
  })
  // Redirect or handle the response after setting the cookie
}
```

**Accessing the session data stored in the cookie in a server component:**

```jsx
import { getCookie } from 'next/cookies'

export async function getSessionData(req) {
  const encryptedSessionData = cookies().get('session')?.value
  return encryptedSessionData ? JSON.parse(decrypt(encryptedSessionData)) : null
}
```

### Database Sessions

Database session management involves storing session data on the server, with the user’s browser only receiving a session ID. This ID references the session data stored server-side, without containing the data itself. This method enhances security, as it keeps sensitive session data away from the client-side environment, reducing the risk of exposure to client-side attacks. Database sessions are also more scalable, accommodating larger data storage needs.

However, this approach has its trade-offs. It can increase performance overhead due to the need for database lookups at each user interaction. Strategies like session data caching can help mitigate this. Additionally, reliance on the database means that session management is as reliable as the database’s performance and availability.

Here's a simplified example of implementing database sessions in a Next.js application:

**Creating a Session on the Server**:

```js
import db from 'path/to/databaseModule'

export async function createSession(user) {
  const sessionId = generateSessionId() // Generate a unique session ID
  await db.insertSession({ sessionId, userId: user.id, createdAt: new Date() })
  return sessionId
}
```

**Retrieving a Session in Middleware or Server-Side Logic**:

```js
import { cookies } from 'next/headers'
import db from 'path/to/databaseModule'

export async function getSession() {
  const sessionId = cookies().get("sessionId")?.value // Assuming session ID is stored in a cookie
  return sessionId ? await db.findSession(sessionId) : null
}
```

### Selecting Session Management in Next.js

Deciding between cookie-based and database sessions in Next.js depends on your application's needs. Cookie-based sessions are simpler and suit smaller applications with lower server load but may offer less security. Database sessions, while more complex, provide better security and scalability, ideal for larger, data-sensitive applications.

With [authentication solutions](https://www.notion.so/Authentication-fec5315fd5de47988e45d0ee1996e3c5?pvs=21) such as NextAuth.js, session management becomes more efficient, using either cookies or database storage. This automation simplifies the development process, but it's important to understand the session management method used by your chosen solution. Ensure it aligns with your application's security and performance requirements.

Regardless of your choice, prioritize security in your session management strategy. For cookie-based sessions, using secure and HTTP-only cookies is crucial to protect session data. For database sessions, regular backups and secure handling of session data are essential. Implementing session expiry and cleanup mechanisms is vital in both approaches to prevent unauthorized access and maintain application performance and reliability.

## Authentication Solutions

Here are authentication solutions compatible with Next.js, please refer to the quickstart guides below to learn how to configure them in your Next.js application:

- [AuthO](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
  {/* TODO: Change link to authjs.dev when new documentation is ready */}
- [NextAuth.js](https://next-auth.js.org/configuration/initialization#route-handlers-app)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)

## Further Reading

To continue learning about authentication and security, checkout the following resources:

- [Understanding XSS Attacks](https://vercel.com/guides/understanding-xss-attacks)
- [Understanding CSRF Attacks](https://vercel.com/guides/understanding-csrf-attacks)
