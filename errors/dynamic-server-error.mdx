---
title: DynamicServerError - Dynamic Server Usage
---

#### Why This Message Occurred

You attempted to use a Next.js function that depends on Async Context (such as `headers` or `cookies` from `next/headers`) but it was not bound to the same call stack as the function that ran it. Next.js will throw a `DynamicServerError` to know when to opt a page into dynamic rendering. However, when it's uncaught, that means that the async context was lost.

## What is Async Context?

[Async Context](https://github.com/tc39/proposal-async-context) is a way to pass data within the same call stack, even through asynchronous operations. This is very useful in Next.js, where functions like cookies or headers might be called from anywhere within a React component tree or other functions during React rendering. However, this context can be lost if certain operations like setTimeout or unhandled Promise rejections are used.

## Scenarios that can cause this to happen

- The function was called inside of a `setTimeout` or `setInterval`, causing the value to be read outside of the call stack that the context was bound to
- The function was called after an async operation, but the promise wasn't returned. This can cause the function to be called after the async operation has completed, resulting in a new execution context and loss of the original async context.
- The function was used in an async context, but errors weren't adequately handled. An unhandled error can cause a function to exit prematurely, leading to a loss of the async context.

### Example of Incorrect Usage

```jsx filename="app/page.js"
import { cookies } from 'next/headers'

async function getCookieData() {
  return new Promise((resolve) =>
    setTimeout(() => {
      // cookies will be called outside of the async context, causing a build-time error
      resolve(cookies().getAll())
    }, 1000)
  )
}

export default async function Page() {
  const cookieData = await getCookieData()
  return <div>Hello World</div>
}
```

## Possible Ways to Fix It

**Return Promises:** Ensure to return Promises when dealing with asynchronous operations. This makes sure that the asynchronous operation completes within the same async context.

**Manage Execution Contexts Correctly:** Understand that JavaScript operations like setTimeout, setInterval, event handlers, and Promises create new execution contexts. You need to maintain the async context when using these operations.

**Handle Errors Appropriately:** Always handle errors in your async functions. Failing to do so can cause an early exit from the function, leading to a loss of the async context.

### Example of Correct Usage

```jsx filename="app/page.js"
import { cookies } from 'next/headers'

async function getCookieData() {
  const cookieData = cookies().getAll()
  return new Promise((resolve) =>
    setTimeout(() => {
      resolve(cookieData)
    }, 1000)
  )
}

export default async function Page() {
  const cookieData = await getCookieData()
  return <div>Hello World</div>
}
```
