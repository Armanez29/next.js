module.exports=(()=>{var e={513:(e,r,t)=>{const o=t(43);const n=t(32);const c=["composes"];const s=new RegExp(`^(${c.join("|")})$`);const a=/^(.+?)\s+from\s+(?:"([^"]+)"|'([^']+)'|(global))$/;const i=/^:import\((?:"([^"]+)"|'([^']+)')\)/;const f=1;function createParentName(e,r){return`__${r.index(e.parent)}_${e.selector}`}function serializeImports(e){return e.map(e=>"`"+e+"`").join(", ")}function addImportToGraph(e,r,t,o){const n=r+"_"+"siblings";const c=r+"_"+e;if(o[c]!==f){if(!Array.isArray(o[n]))o[n]=[];const r=o[n];if(Array.isArray(t[e]))t[e]=t[e].concat(r);else t[e]=r.slice();o[c]=f;r.push(e)}}e.exports=o.plugin("modules-extract-imports",function(e={}){const r=e.failOnWrongOrder;return t=>{const c={};const f={};const p={};const l={};const u={};let _=0;const d=typeof e.createImportedName!=="function"?e=>`i__imported_${e.replace(/\W/g,"_")}_${_++}`:e.createImportedName;t.walkRules(e=>{const r=i.exec(e.selector);if(r){const[,t,o]=r;const n=t||o;addImportToGraph(n,"root",c,f);p[n]=e}});t.walkDecls(s,e=>{let r=e.value.match(a);let o;if(r){let[,n,s,a,i]=r;if(i){o=n.split(/\s+/).map(e=>`global(${e})`)}else{const r=s||a;const i=createParentName(e.parent,t);addImportToGraph(r,i,c,f);l[r]=e;u[r]=u[r]||{};o=n.split(/\s+/).map(e=>{if(!u[r][e]){u[r][e]=d(e,r)}return u[r][e]})}e.value=o.join(" ")}});const m=n(c,r);if(m instanceof Error){const e=m.nodes.find(e=>l.hasOwnProperty(e));const r=l[e];const t="Failed to resolve order of composed modules "+serializeImports(m.nodes)+".";throw r.error(t,{plugin:"modules-extract-imports",word:"composes"})}let w;m.forEach(e=>{const r=u[e];let n=p[e];if(!n&&r){n=o.rule({selector:`:import("${e}")`,raws:{after:"\n"}});if(w)t.insertAfter(w,n);else t.prepend(n)}w=n;if(!r)return;Object.keys(r).forEach(e=>{n.append(o.decl({value:e,prop:r[e],raws:{before:"\n  "}}))})})}})},32:e=>{const r=2;const t=1;function createError(e,r){const t=new Error("Nondeterministic import's order");const o=r[e];const n=o.find(t=>r[t].indexOf(e)>-1);t.nodes=[e,n];return t}function walkGraph(e,o,n,c,s){if(n[e]===r)return;if(n[e]===t){if(s)return createError(e,o);return}n[e]=t;const a=o[e];const i=a.length;for(let e=0;e<i;++e){const r=walkGraph(a[e],o,n,c,s);if(r instanceof Error)return r}n[e]=r;c.push(e)}function topologicalSort(e,r){const t=[];const o={};const n=Object.keys(e);const c=n.length;for(let s=0;s<c;++s){const c=walkGraph(n[s],e,o,t,r);if(c instanceof Error)return c}return t}e.exports=topologicalSort},43:e=>{"use strict";e.exports=require("postcss")}};var r={};function __nccwpck_require__(t){if(r[t]){return r[t].exports}var o=r[t]={exports:{}};var n=true;try{e[t](o,o.exports,__nccwpck_require__);n=false}finally{if(n)delete r[t]}return o.exports}__nccwpck_require__.ab=__dirname+"/";return __nccwpck_require__(513)})();